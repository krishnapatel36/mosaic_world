<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Push Pin Art</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #000; /* Black background */
            color: #fff; /* White text */
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            min-height: 100vh;
        }

        h1, h2 {
            color: #fff; /* White text */
        }

        .container {
            width: 90%;
            /* max-width: 800px; */
            background-color: #222; /* Dark gray background for container */
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        input[type="number"],
        input[type="text"],
        button {
            width: 100%;
            padding: 10px;
            margin-top: 5px;
            border: 1px solid #444; /* Darker border color */
            border-radius: 5px;
            box-sizing: border-box;
            background-color: #333; /* Dark input and button background */
            color: #fff; /* White text */
        }

        input[type="number"]:focus,
        input[type="text"]:focus,
        button:focus {
            outline: none;
            border-color: #555; /* Lighter border color on focus */
        }

        .color-picker-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .color-picker-group input[type="color"] {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .color-picker-group input[type="color"]:hover {
            transform: scale(1.1);
        }

        canvas {
            border-radius: 10px;
            border: 2px solid #444; /* Darker border color */
            width: 100%;
            height: auto;
            display: none; /* Initially hide canvases */
        }

        .download-link,
        button {
            background-color: #007bff; /* Primary button color */
            color: white;
            text-decoration: none;
            border-radius: 5px;
            transition: background-color 0.2s ease;
        }

        .download-link:hover,
        button:hover {
            background-color: #0056b3; /* Darker button color on hover */
        }
    </style>
</head>
<body>
    <div class="container">
        <img class="w-100" style="height: auto; max-height: 200px;" src="iitgn_logo.png" alt="IITGN Logo">
        <br><br>
        <center><h1>Push Pin Art</h1></center>
        <br>
        <center><div id="display_image"></div></center>

        <div class="form-group">
            <label for="totalPixels">Total Pins:</label>
            <input type="text" id="totalPixels" placeholder="Enter total pixels">
        </div>
        
        <div class="form-group">
            <label for="numColors">Number of Colors:</label>
            <input type="number" id="numColors" min="1" value="1">
        </div>
        
        <div id="colorPickers" class="color-picker-group"></div>
        
        <button onclick="applyDithering()">Apply Dithering</button>
        
        <div class="result-group">
            <canvas id="ditheredCanvas"></canvas>
        </div>
        
        <button id="downloadImageBtn" style="display:none;" onclick="downloadImage()">Download Output Image</button>
        <button id="downloadPdfBtn" style="display:none;" onclick="downloadPDF()">Download Output PDF</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.4.0/jspdf.umd.min.js"></script>
    <script>
        // Get image URL from local storage
        var imageUrl = localStorage.getItem('finalImageUrl');

        if (imageUrl) {
            document.getElementById('display_image').innerHTML = 
                '<img id="image_element" src="'+imageUrl+'"/>';
        } else {
            document.getElementById('display_image').innerHTML = 
                '<p>No image found.</p>';
        }

        document.getElementById('numColors').addEventListener('input', function() {
            let numColors = parseInt(this.value);
            let colorPickersDiv = document.getElementById('colorPickers');
            colorPickersDiv.innerHTML = '';
            
            for (let i = 0; i < numColors; i++) {
                let label = document.createElement('label');
                label.innerHTML = `Select Color ${i + 1}: `;
                let colorPicker = document.createElement('input');
                colorPicker.type = 'color';
                colorPicker.id = `color${i}`;
                colorPickersDiv.appendChild(label);
                colorPickersDiv.appendChild(colorPicker);
                colorPickersDiv.appendChild(document.createElement('br'));
            }
        });

        function applyDithering() {
            let totalPixels = document.getElementById('totalPixels').value;
            let numColors = document.getElementById('numColors').value;
            let colors = [];

            for (let i = 0; i < numColors; i++) {
                colors.push(hexToRgb(document.getElementById(`color${i}`).value));
            }

            if (!imageUrl || !totalPixels || colors.length < 2) {
                alert("Please fill in all fields and select at least two colors.");
                return;
            }

            let img = new Image();
            img.src = imageUrl;
            img.onload = function() {
                let ditheredCanvas = document.getElementById('ditheredCanvas');
                let ditheredContext = ditheredCanvas.getContext('2d');
                let aspectRatio = img.width / img.height;
                let newWidth = Math.sqrt(totalPixels * aspectRatio);
                let newHeight = totalPixels / newWidth;

                ditheredCanvas.width = newWidth;
                ditheredCanvas.height = newHeight;

                let tempCanvas = document.createElement('canvas');
                tempCanvas.width = newWidth;
                tempCanvas.height = newHeight;
                let tempContext = tempCanvas.getContext('2d');
                tempContext.drawImage(img, 0, 0, newWidth, newHeight);

                ditheredContext.drawImage(ditherCanvas(tempCanvas, colors), 0, 0);

                document.getElementById('ditheredCanvas').style.display = 'block';
                document.getElementById('downloadImageBtn').style.display = 'inline';
                document.getElementById('downloadPdfBtn').style.display = 'inline';
            };
        }

        function ditherCanvas(canvas, colors) {
            let width = canvas.width;
            let height = canvas.height;
            let context = canvas.getContext('2d');
            let imageData = context.getImageData(0, 0, width, height);
            let data = imageData.data;

            for (let y = 1; y < height; y++) {
                for (let x = 1; x < width; x++) {
                    let i = (y * width + x) * 4;
                    let oldPixel = [data[i], data[i + 1], data[i + 2]];
                    let newPixel = findClosestColor(oldPixel, colors);

                    data[i] = newPixel[0];
                    data[i + 1] = newPixel[1];
                    data[i + 2] = newPixel[2];

                    let quantError = oldPixel.map((old, idx) => old - newPixel[idx]);

                    distributeError(data, x, y, width, height, quantError);
                }
            }

            context.putImageData(imageData, 0, 0);
            return canvas;
        }

        function findClosestColor(pixel, colors) {
            let closestColor = colors.reduce((closest, color) => {
                let distance = Math.sqrt(
                    Math.pow(pixel[0] - color[0], 2) +
                    Math.pow(pixel[1] - color[1], 2) +
                    Math.pow(pixel[2] - color[2], 2)
                );

                return distance < closest.distance ? { color, distance } : closest;
            }, { color: colors[0], distance: Infinity });

            return closestColor.color;
        }

        function distributeError(data, x, y, width, height, error) {
            let index = (y * width + x) * 4;
            if (x + 1 < width) {
                let i = index + 4;
                data[i] += error[0] * 7 / 16;
                data[i + 1] += error[1] * 7 / 16;
                data[i + 2] += error[2] * 7 / 16;
            }
            if (x - 1 >= 0 && y + 1 < height) {
                let i = (y + 1) * width * 4 + (x - 1) * 4;
                data[i] += error[0] * 3 / 16;
                data[i + 1] += error[1] * 3 / 16;
                data[i + 2] += error[2] * 3 / 16;
            }
            if (y + 1 < height) {
                let i = (y + 1) * width * 4 + x * 4;
                data[i] += error[0] * 5 / 16;
                data[i + 1] += error[1] * 5 / 16;
                data[i + 2] += error[2] * 5 / 16;
            }
            if (x + 1 < width && y + 1 < height) {
                let i = (y + 1) * width * 4 + (x + 1) * 4;
                data[i] += error[0] * 1 / 16;
                data[i + 1] += error[1] * 1 / 16;
                data[i + 2] += error[2] * 1 / 16;
            }
        }

        function hexToRgb(hex) {
            hex = hex.replace(/^#/, '');
            if (hex.length === 3) {
                hex = hex.split('').map(function (hex) {
                    return hex + hex;
                }).join('');
            }

            let bigint = parseInt(hex, 16);
            return [ (bigint >> 16) & 255, (bigint >> 8) & 255, bigint & 255 ];
        }

        function downloadImage() {
            let canvas = document.getElementById('ditheredCanvas');
            let imageURL = canvas.toDataURL('image/png');
            let link = document.createElement('a');
            link.href = imageURL;
            link.download = 'dithered_image.png';
            link.click();
        }

        function downloadPDF() {
            let totalPinsRequested = parseInt(document.getElementById('totalPixels').value);
            let ditheredCanvas = document.getElementById('ditheredCanvas');
            let imageURL = ditheredCanvas.toDataURL('image/png');
            createPDFFromImage(imageURL, totalPinsRequested);
        }

        function createPDFFromImage(mosaicImageURL, totalPinsRequested) {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF('portrait', 'px', 'a4');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            const img = new Image();
            img.src = mosaicImageURL;

            img.onload = function () {
                const imgWidth = img.width;
                const imgHeight = img.height;

                // Calculate block size based on the total number of pins
                const blockSize = Math.ceil(Math.sqrt((imgWidth * imgHeight) / totalPinsRequested));

                // Set canvas dimensions to match the image
                canvas.width = imgWidth;
                canvas.height = imgHeight;
                ctx.drawImage(img, 0, 0, imgWidth, imgHeight);

                // Calculate grid width and height
                const gridWidth = 18 * blockSize;
                const gridHeight = 26 * blockSize;

                let pageIndex = 0;
                for (let y = 0; y < imgHeight; y += gridHeight) {
                    for (let x = 0; x < imgWidth; x += gridWidth) {
                        const pageCanvas = document.createElement('canvas');
                        const pageCtx = pageCanvas.getContext('2d');

                        pageCanvas.width = gridWidth;
                        pageCanvas.height = gridHeight;

                        pageCtx.drawImage(
                            canvas,
                            x, y, gridWidth, gridHeight,
                            0, 0, gridWidth, gridHeight
                        );

                        const imgData = pageCanvas.toDataURL('image/png');
                        if (pageIndex > 0) {
                            pdf.addPage();
                        }
                        pdf.addImage(imgData, 'PNG', 0, 0, pdf.internal.pageSize.width, pdf.internal.pageSize.height);

                        // Draw grid lines on the PDF page
                        const pageWidth = pdf.internal.pageSize.width;
                        const pageHeight = pdf.internal.pageSize.height;

                        pdf.setDrawColor(0, 0, 0); // Set grid line color
                        pdf.setLineWidth(0.5);

                        for (let gy = 0; gy <= gridHeight; gy += blockSize) {
                            pdf.line(0, gy * (pageHeight / gridHeight), pageWidth, gy * (pageHeight / gridHeight));
                        }

                        for (let gx = 0; gx <= gridWidth; gx += blockSize) {
                            pdf.line(gx * (pageWidth / gridWidth), 0, gx * (pageWidth / gridWidth), pageHeight);
                        }

                        pageIndex++;
                    }
                }

                pdf.save('mosaic_output.pdf');
            };
        }
    </script>
</body>
</html>
