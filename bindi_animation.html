<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circle Animation</title>
  <style>
    body {
      zoom:10%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-top: 100px;
      background-color: black;
    }

    #grid-container {
      display: grid;
    }

    .circle {
      width: 100px;
      height: 100px;
      border: 5px solid white;
      border-radius: 100%;
      background-color: white;
      transition: width 0.2s, height 0.2s; /* Longer transition time for smoother effect */
    }
  </style>
</head>
<body>
  <div id="grid-container">
    <!-- Circles will be dynamically generated here -->
  </div>

  <script>
    const matrixSize = parseInt(localStorage.getItem('matrixSize')) || 2;
    const targetDiameters = JSON.parse(localStorage.getItem('matrix')) || [[10, 30], [40, 20]];
    const animationDuration = 10000; // Duration of the animation in milliseconds
    const rowDelay = 100; // Delay between rows in milliseconds
    const transitionDuration = 2000; // Duration of each circle transition in milliseconds
    let diameters = Array.from({ length: matrixSize }, () => Array(matrixSize).fill(0));
    let startTime = Date.now();
    let stopTransition = false;

    const gridContainer = document.getElementById('grid-container');
    gridContainer.style.gridTemplateColumns = `repeat(${matrixSize}, 100px)`;
    gridContainer.style.gridTemplateRows = `repeat(${matrixSize}, 100px)`;

    for (let i = 0; i < matrixSize; i++) {
      for (let j = 0; j < matrixSize; j++) {
        const circle = document.createElement('div');
        circle.classList.add('circle');
        gridContainer.appendChild(circle);
      }
    }

    const circles = document.querySelectorAll('.circle');

    function updateDiameters() {
      const elapsedTime = Date.now() - startTime;
      const progress = Math.min(elapsedTime / animationDuration, 1);

      for (let i = 0; i < matrixSize; i++) {
        for (let j = 0; j < matrixSize; j++) {
          const delay = i * rowDelay; // Delay for each row animation
          const time = Math.max(0, elapsedTime - delay);
          const rowProgress = Math.min(time / (animationDuration - delay), 1);
          const targetDiameter = targetDiameters[i][j] * 16;
          diameters[i][j] = lerp(20, targetDiameter, rowProgress);
        }
      }
    }

    function lerp(start, end, amt) {
      return (1 - amt) * start + amt * end;
    }

    function drawCircles() {
      circles.forEach((circle, index) => {
        const row = Math.floor(index / matrixSize);
        const col = index % matrixSize;
        const diameter = diameters[row][col];
        circle.style.width = `${diameter}px`;
        circle.style.height = `${diameter}px`;
      });
    }

    function animate() {
      const currentTime = Date.now();
      const elapsedTime = currentTime - startTime;

      if (elapsedTime < animationDuration) {
        updateDiameters();
      } else {
        stopTransition = true;
        updateDiameters();
      }

      drawCircles();

      if (stopTransition && allDiametersCloseToTarget()) {
        return;
      }

      requestAnimationFrame(animate);
    }

    function allDiametersCloseToTarget() {
      for (let i = 0; i < matrixSize; i++) {
        for (let j = 0; j < matrixSize; j++) {
          if (Math.abs(diameters[i][j] - (targetDiameters[i][j] * 16)) > 1) {
            return false;
          }
        }
      }
      return true;
    }

    // Start the animation
    animate();
  </script>
</body>
</html>
